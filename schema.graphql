# The supplyRateMantissa and borrowRateMantissa are the per block return on an asset borrowed/supplied
type Market @entity {
    id: ID!                         # asset address (i.e. actual token address)
    symbol: String!                 # i.e. cDAI, cBAT, etc.
    accrualBlockNumber: BigInt!     # block number the market is updated to, which is the last block a trade on this market occurred

    totalSupply: BigInt!            # CToken total supply. CTokens have 10 decimal points
    exchangeRate: BigInt!           # Exchange rate between cTokens and reserves
    totalReserves: BigInt!          # Total reserves stored in the market

    totalBorrows: BigInt!           # Total borrows for the market
    perBlockBorrowInterest: BigInt! # To get Annual Percent Return : perBlockBorrowInterest * 2102400 * 10 ^-18,
    borrowIndex: BigInt!            # The history of the markets borrow index return since inception. (Think S&P 500)

    # TODO - figure this out, if i can use and if i need. would get from the price oracle
    # price is w.r.t. Wei. So If Ether is $150 USD, one Dai would be 1/150 * 10^18.
    # To get asset prices in USD, divide this by DAIS priceInWei. Dai is obviously ~ $1.00
    # priceInWei: BigInt
}

# note - account liqidity is how much ETH is available to be collaterailzed, but keep in mind it still needs to
# meet the 150%. So 150 ETH would mean if you borrowed 100 ETH, it would go to 0 for liquidity.
type User @entity {
    id: ID!                                             # user eth address
    assets: [UserAsset!]! @derivedFrom(field: "user")   # derivedFrom will allow all UserAssets to have a one-to-many-relationship
    accountLiquidity: BigInt                            # TODO - get from a function, prob in Comptroller
    totalSupplyInEth: BigInt                            # TODO - get from a function, prob in Comptroller
    totalBorrowInEth: BigInt                            # TODO - get from a function, prob in Comptroller
}

# An Asset represents a User's ownership of CTokens
# It must be its own entity type, so that we have a one to many relationship under User.assets
type UserAsset @entity {
    id: ID!                             # concatenation of the asset name and user eth address (i.e. cDAI-0xdA5d.......)
    user: Bytes!                        # user address for one-to-many relationships
    transactionHashes: [Bytes!]!        # each tx hash is recorded. makes for easily displaying in a Dapp
    transactionTimes: [Int!]!           # each tx block time is recorded. makes for easily displaying in a Dapp

    reservePrincipal: BigInt!           # total amount the user has supplied in this market
    cTokenBalance: BigInt!              # total ctokens the user owns of this asset
    reserveBalance: BigInt!             # Increase in Reserve balance due to inflation: (cTokenBalance * exchangeRate) - reserveBalance
    cTokenIndex: BigInt!                # % Increase in Reserve balance due to inflation: reserveBalance / reservePrincipal

    borrowPrincipal: BigInt!            # total borrow, exclusive of interest
    borrowBalance: BigInt!              # total borrow, inclusive of interest
    borrowInterest: BigInt!             # Increase in Borrow  balance due to inflation: borrowBalance - borrowPrincipal
    borrowIndex: BigInt!                # % Increase in Borrow balance due to inflation: (borrowBalance - borrowPrincipal) / borrowPrincipal
}