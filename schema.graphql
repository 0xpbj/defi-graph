# note : cash + borrows = deposits + reserves
type Market @entity {
    id: ID!                         # asset address (i.e. actual token address)
    symbol: String!                 # i.e. cDAI, cBAT, etc.
    accrualBlockNumber: BigInt!     # block number the market is updated to, which is the last block a trade on this market occurred

    totalSupply: BigInt!            # CToken total supply. CTokens have 10 decimal points
    exchangeRate: BigInt!           # Exchange rate between cTokens and reserves
    totalReserves: BigInt!          # Reserves accrue from a small % of all interest being shaved off for the protocol
    totalDeposits: BigInt!          # The total lending of erc20 or eth given to this contract

    totalCash: BigInt!              # The true balance of the contracts ERC20 or Ether. Read from the actual ERC20 contract, or the ETH balance of the contract. NOT stored in CErc20.sol.
    totalBorrows: BigInt!           # Total borrows for the market
    perBlockBorrowInterest: BigInt! # To get Annual Percent Return : perBlockBorrowInterest * 2102400 * 10 ^-18,
    borrowIndex: BigInt!            # The history of the markets borrow index return since inception. (Think S&P 500)

    # TODO - figure this out, if i can use and if i need. would get from the price oracle
    # price is w.r.t. Wei. So If Ether is $150 USD, one Dai would be 1/150 * 10^18.
    # To get asset prices in USD, divide this by DAIS priceInWei. Dai is obviously ~ $1.00
    # priceInWei: BigInt
}

# note - account liqidity is how much ETH is available to be collaterailzed, but keep in mind it still needs to
# meet the 150%. So 150 ETH would mean if you borrowed 100 ETH, it would go to 0 for liquidity.
type User @entity {
    id: ID!                                             # user eth address
    assets: [UserAsset!]! @derivedFrom(field: "user")   # derivedFrom will allow all UserAssets to have a one-to-many-relationship
    accountLiquidity: BigInt                            # TODO - get from a function, prob in Comptroller
    totalSupplyInEth: BigInt                            # TODO - get from a function, prob in Comptroller
    totalBorrowInEth: BigInt                            # TODO - get from a function, prob in Comptroller
}

# An Asset represents a User's ownership of CTokens
# It must be its own entity type, so that we have a one to many relationship under User.assets
type UserAsset @entity {
    id: ID!                             # concatenation of the asset name and user eth address (i.e. cDAI-0xdA5d.......)
    user: Bytes!                        # user address for one-to-many relationships
    transactionHashes: [Bytes!]!        # each tx hash is recorded. makes for easily displaying in a Dapp
    transactionTimes: [Int!]!           # each tx block time is recorded. makes for easily displaying in a Dapp
    accrualBlockNumber: BigInt!         # block number the user balances are updated to


    cTokenBalance: BigInt!              # total ctokens the user owns of this asset
    underlyingSupplied: BigInt!         # Total amount the user has supplied of the underlying ERC20 or ETH
    underlyingRedeemed: BigInt!         # Total amount the user has redeemed of the underlying ERC20 or ETH
    underlyingBalance: BigInt!          # Principal plus inflation earned: (cTokenBalance * exchangeRate)
    interestEarned: BigInt!             # interestEarned = underlyingBalance - sum(underlyingSupplied) + sum(underlyingRedeemed)

    totalBorrowed: BigInt!              # total borrow, exclusive of interest
    totalRepaid: BigInt!                # total repaid
    borrowBalance: BigInt!              # total borrow, inclusive of interest, that must be repaid
    borrowInterest: BigInt!             # borrowInterest = borrowBalance - totalBorrowed + totalRepaid
}

# TODO - add in counting transfers of ctokens, and keeping it seperate from interest
# The only way to make interest is by holding  Ctokens
    # you can buy Ctoknes, and with that one purchase it is easy to tell how much you have made
    # but when you start entering adn exiting the market , it gets confusing
    # also gets confusing when you get transfered ctokens and you never bought before
    # how does rbc do it?
        # if I hadd more, my underlyingIndex goes down a lot, 110% doubled becomes 55%
        # if i sold, i would still have same percentrage
        # EDGE CASE - if you sell all, your personal index is 0. (ANY TIME IT RESETS TO ZERO, %'s are lost
            # but you should record profit somewhere in units of token